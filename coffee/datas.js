// Generated by CoffeeScript 1.8.0
(function() {
  this.player = function(name) {
    if (!name) {
      name = '无名牌手';
    }
    this.name = name;
    this.results = [];
    this.matches = [];
    return this;
  };

  this.player.resultScores = {
    'win': config.score.winScore,
    'lose': config.score.loseScore,
    'peace': config.score.peaceScore,
    'bye': config.score.byeScore
  };

  this.player.prototype.win = function() {
    return this.results.push('win');
  };

  this.player.prototype.bye = function() {
    this.results.push('bye');
    return this.matches.push(null);
  };

  this.player.prototype.peace = function() {
    return this.results.push('peace');
  };

  this.player.prototype.lose = function() {
    return this.results.push('lose');
  };

  this.player.prototype.rollback = function() {
    return this.results.pop();
  };

  this.player.prototype.getScore = function() {
    var result, sum, _i, _len, _ref;
    sum = 0;
    _ref = this.results;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      sum += player.resultScores[result];
    }
    return sum;
  };

  this.player.prototype.getResultCount = function(searchingResult) {
    var count, result, _i, _len, _ref;
    count = 0;
    _ref = this.results;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      if (result === searchingResult) {
        count += 1;
      }
    }
    return count;
  };

  Object.defineProperty(this.player.prototype, 'winCount', {
    get: function() {
      return this.getResultCount('win');
    }
  });

  Object.defineProperty(this.player.prototype, 'loseCount', {
    get: function() {
      return this.getResultCount('lose');
    }
  });

  Object.defineProperty(this.player.prototype, 'peaceCount', {
    get: function() {
      return this.getResultCount('peace');
    }
  });

  Object.defineProperty(this.player.prototype, 'byeCount', {
    get: function() {
      return this.getResultCount('bye');
    }
  });

  this.player.prototype.winLoseStr = function() {
    var draw, str;
    str = this.winCount + "-";
    draw = this.peaceCount;
    str += draw === 0 ? "" : draw + "-";
    str += this.loseCount;
    return str;
  };

  this.player.prototype.anotherPlayer = function(match) {
    return match.anotherPlayer(this);
  };

  this.player.prototype.resultStr = function(match) {
    return match.resultStr(this);
  };

  Object.defineProperty(this.player.prototype, 'score', {
    get: this.player.prototype.getScore
  });

  this.match = function(player1, player2, order) {
    this.player1 = player1;
    this.player2 = player2;
    this.player1.matches.push(this);
    this.player2.matches.push(this);
    this.actualState = 'waiting';
    this.order = order;
    return this;
  };

  this.match.prototype.getState = function() {
    return this.actualState;
  };

  this.match.prototype.setState = function(state) {
    switch (this.actualState) {
      case 'win':
      case 'lose':
      case 'peace':
        this.player1.rollback();
        this.player2.rollback();
    }
    switch (state) {
      case 'win':
        this.player1.win();
        this.player2.lose();
        break;
      case 'lose':
        this.player1.lose();
        this.player2.win();
        break;
      case 'peace':
        this.player1.peace();
        this.player2.peace();
        break;
      case 'matching':
        'matching';
        break;
      case 'waiting':
        'waiting';
    }
    return this.actualState = state;
  };

  this.match.prototype.containPlayer = function(player) {
    return this.player1 === player || this.player2 === player;
  };

  this.match.prototype.containPlayers = function(player1, player2) {
    return (this.player1 === player1 && this.player2 === player2) || (this.player1 === player2 && this.player2 === player1);
  };

  this.match.prototype.str = function() {
    return this.player1.name + " 对阵 " + this.player2.name;
  };

  this.match.prototype.stateStr = function() {
    switch (this.state) {
      case 'win':
        return this.player1.name + '胜利';
      case 'lose':
        return this.player2.name + '胜利';
      case 'peace':
        return '双方平局';
      case 'matching':
        return '正在进行';
      case 'waiting':
        return '等待开始';
    }
  };

  this.match.prototype.anotherPlayer = function(player) {
    if (player === null || player === void 0) {
      player = this.player1;
    }
    if (player !== this.player1 && player !== this.player2) {
      return null;
    }
    if (player === this.player1) {
      return this.player2;
    } else {
      return this.player1;
    }
  };

  this.match.prototype.resultStr = function(player) {
    if (player === null || player === void 0) {
      player = this.player1;
    }
    if (player !== this.player1 && player !== this.player2) {
      return "";
    }
    switch (this.state) {
      case 'win':
        if (this.player1 === player) {
          return '胜利';
        } else {
          return '败北';
        }
        break;
      case 'lose':
        if (this.player2 === player) {
          return '胜利';
        } else {
          return '败北';
        }
        break;
      case 'peace':
        return '平局';
      case 'matching':
        return '正在进行';
      case 'waiting':
        return '等待开始';
    }
  };

  this.match.prototype.reportStr = function() {
    switch (this.state) {
      case 'win':
        return this.player1.name + ' 战胜了 ' + this.player2.name;
      case 'lose':
        return this.player2.name + ' 战胜了 ' + this.player1.name;
      case 'peace':
        return this.player1.name + ' 与 ' + this.player2.name + ' 战平';
      case 'matching':
        return this.player1.name + ' 与 ' + this.player2.name + ' 正在进行对局';
      case 'waiting':
        return this.player1.name + ' 与 ' + this.player2.name + ' 正在等待开始';
    }
  };

  Object.defineProperty(this.match.prototype, 'state', {
    get: this.match.prototype.getState,
    set: this.match.prototype.setState
  });

  this.round = function(order) {
    this.matches = [];
    this.byePlayer = null;
    this.order = order;
    return this;
  };

  this.round.prototype.generate = function(players) {
    var byeIndex, index, matchingPlayerA, matchingPlayerB, operatingPlayers;
    console.log('开始匹配');
    this.waiting_player = null;
    operatingPlayers = players.slice(0);
    if (players.length % 2 === 1) {
      byeIndex = Math.floor(Math.random() * players.length);
      this.byePlayer = players[byeIndex];
      this.byePlayer.bye();
      console.log("" + this.byePlayer.name + " 轮空");
      operatingPlayers.splice(byeIndex, 1);
    }
    operatingPlayers = this.sortPlayers(operatingPlayers);
    while (operatingPlayers.length > 0) {
      matchingPlayerA = operatingPlayers[0];
      index = 1;
      console.log("试图匹配: " + matchingPlayerA.name + ", " + operatingPlayers[index].name);
      while (data.hasMet(matchingPlayerA, operatingPlayers[index])) {
        index += 1;
        console.log("试图匹配: " + matchingPlayerA.name + ", " + operatingPlayers[index].name);
        if (index >= operatingPlayers.length) {
          break;
        }
      }
      matchingPlayerB = operatingPlayers[index];
      console.log("第 " + (this.matches.length + 1) + " 桌：" + matchingPlayerA.name + " - " + matchingPlayerB.name);
      this.matches.push(new match(matchingPlayerA, matchingPlayerB, this.matches.length + 1));
      operatingPlayers.splice(index, 1);
      operatingPlayers.splice(0, 1);
    }
    return this.matches;
  };

  this.round.prototype.sortPlayers = function(players) {
    players.sort(function(playerA, playerB) {
      if (playerA.score === playerB.score) {
        return Math.random() > 0.5;
      } else {
        return playerB.score - playerA.score;
      }
    });
    return players;
  };

  this.round.prototype.startAll = function() {
    var match, _i, _len, _ref, _results;
    this.byePlayer.bye();
    _ref = this.matches;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      match = _ref[_i];
      if (match.state === 'waiting') {
        _results.push(match.state = 'matching');
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  this.round.prototype.canFinish = function() {
    var match, _i, _len, _ref;
    _ref = this.matches;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      match = _ref[_i];
      if (match.state === 'waiting' || match.state === 'matching') {
        return false;
      }
    }
    return true;
  };

  this.round.prototype.finish = function() {};

  this.round.prototype.searchPlayer = function(player) {
    var match, _i, _len;
    if (player === this.byePlayer) {
      return null;
    }
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      match = matches[_i];
      if (match.containPlayer(player)) {
        return match;
      }
    }
    return void 0;
  };

  this.round.prototype.searchPlayers = function(player1, player2) {
    var match, _i, _len;
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      match = matches[_i];
      if (match.containPlayers(player1, player2)) {
        return match;
      }
    }
    return null;
  };

  this.data = function() {};

  this.data.players = [];

  this.data.rounds = [];

  this.data.searchPlayerMatch = function(player) {
    var matches, round, _i, _len, _ref;
    matches = [];
    _ref = this.rounds;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      round = _ref[_i];
      matches.push(round.searchMatch(player));
    }
    return matches;
  };

  this.data.searchPlayers = function(player1, player2) {
    var match, round, _i, _len, _ref;
    _ref = this.rounds;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      round = _ref[_i];
      match = round.containPlayers(player1, player2);
      if (match !== null) {
        return match;
      }
    }
    return null;
  };

  this.data.newRound = function() {
    var newRound;
    newRound = new round(this.rounds.length + 1);
    newRound.generate(data.players);
    this.rounds.push(newRound);
    return newRound;
  };

  this.data.getRunningRound = function() {
    return this.rounds[this.rounds.length - 1];
  };

  this.data.addPlayer = function(name) {
    return this.players.push(new player(name));
  };

  this.data.hasMet = function(player1, player2) {
    var match, _i, _len, _ref;
    if (!player1 || !player2) {
      return null;
    }
    _ref = player1.matches;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      match = _ref[_i];
      if (match !== null) {
        if (player1.anotherPlayer(match) === player2) {
          return true;
        }
      }
    }
    return false;
  };

  Object.defineProperty(this.data, 'runningRound', {
    get: this.data.getRunningRound
  });

}).call(this);

//# sourceMappingURL=datas.js.map
